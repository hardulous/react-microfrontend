WHEN BUILDING MF APPLICATION FOR PRODUCTION ::

1. There will be zero coupling between child mf that is no communication in between children mf 

2. There will near zero coupling between container/host and child mf that is little bit of communication between host and children mf can be done in the form of simple events , callback etc..

3. Each mf must be independent or generic in nature

4. Css of one project should not effect other project css

5. When exposing mount function to mount the micorfrontend in host app we need to find the way to make use of mount function in host application. We do have easy approach in react is to expose a react component and host which is itself a react can easily use react component but we need to write code that work in longer term because now if we in future let say change container stack from react to vue let say then vue does not know how to use react component so in this case we need to find a generic approach that work for every framework almost

6. When working with css in micorfrontend , css work differently for both development and production environment , For ex , let say you have 2 mf app in which one is signIn page and one is auth page now assume we are currently in signIn page and now navigate to auth page in which there is css of h1 :{ color : green } , now this css is loaded in browser and after this if we navigate back to signIn page the h1 css is still loaded in browser which result in css conflict. Reason this happend in production is because in production the classname generated by mui makeStyle is random with prefix of jss1 , jss2 etc.. , but as both mf are different but using same mui libarary so both can generate jss1 , jss2 etc.. classname which can colide with each other

7. In order to solve css conflict problem we have option like , css-in-js , css module etc that makes css automatically scoped for us. In mui maeStyle we can use 

8. When performing navigation in mf apps we generally make container app to use BrowserHistory while our mf app will use MemoryHistory , Here assume container use BrowserHistory and marketing use MemoryHistory so in container click on any link will always change BrowserHistory object where as click on any link in marketing will always change MemoryHistory object they are kind of scoped , So we need to kind of sync all these history object change together . But in developemt all sub app if need routing will offcoure use BrowserHistory instead of MemoryHistory